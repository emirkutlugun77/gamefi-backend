import { Repository } from 'typeorm';
import { Task } from '../entities/task.entity';
import { UserTask } from '../entities/user-task.entity';
import { User } from '../entities/user.entity';
import { CreateTaskDto } from './dto/create-task.dto';
import { UpdateTaskDto } from './dto/update-task.dto';
import { SubmitTaskDto } from './dto/submit-task.dto';
import { VerifyTaskDto } from './dto/verify-task.dto';
import { NftCollection } from '../entities/nft-collection.entity';
import { NftType } from '../entities/nft-type.entity';
import { TaskInputUser } from '../entities/task-input-user.entity';
import { UserCodeService } from './services/user-code.service';
export declare class AchievementsService {
    private readonly taskRepository;
    private readonly userTaskRepository;
    private readonly userRepository;
    private readonly nftCollectionRepository;
    private readonly nftTypeRepository;
    private readonly taskInputUserRepository;
    private readonly userCodeService;
    constructor(taskRepository: Repository<Task>, userTaskRepository: Repository<UserTask>, userRepository: Repository<User>, nftCollectionRepository: Repository<NftCollection>, nftTypeRepository: Repository<NftType>, taskInputUserRepository: Repository<TaskInputUser>, userCodeService: UserCodeService);
    createTask(createTaskDto: CreateTaskDto): Promise<Task>;
    getAllTasks(): Promise<Task[]>;
    getActiveTasks(): Promise<Task[]>;
    getTaskById(id: number): Promise<Task>;
    updateTask(id: number, updateTaskDto: UpdateTaskDto): Promise<Task>;
    deleteTask(id: number): Promise<void>;
    getUserTasks(publicKey: string): Promise<UserTask[]>;
    getUserTasksWithDetails(publicKey: string): Promise<any[]>;
    submitTask(submitTaskDto: SubmitTaskDto): Promise<UserTask>;
    verifyTask(verifyTaskDto: VerifyTaskDto): Promise<UserTask>;
    getPendingVerifications(): Promise<UserTask[]>;
    getUserStats(publicKey: string): Promise<any>;
    submitTextTask(taskId: number, publicKey: string, textContent: string): Promise<{
        taskInput: TaskInputUser;
        userTask: UserTask;
        video_url: string | null;
        webhook_url: string | null;
        generated_code: string | null;
        code_expires_at: Date | string | null;
    }>;
    submitImageTask(taskId: number, publicKey: string, imageUrl: string, description?: string, metadata?: Record<string, any>): Promise<TaskInputUser>;
    reviewTaskInput(inputId: number, approved: boolean, reviewedBy: number, reviewComment?: string): Promise<TaskInputUser>;
    getUserTaskInputs(publicKey: string): Promise<TaskInputUser[]>;
    getPendingTaskInputs(): Promise<TaskInputUser[]>;
    private canCompleteTask;
    getTaskConfigOptions(): Promise<Record<string, any>>;
    private normalizeStatus;
    private computeTimeDrivenStatus;
    private syncTaskStatuses;
    private syncAllTimeBoundTaskStatuses;
}
